package main

import (
	"bytes"
	"embed"
	"html/template"
	"io/fs"
	"log"
	"os"
	"strings"

	flags "github.com/jessevdk/go-flags"
)

//go:embed templates
var content embed.FS

var feelFreeToEditPrefix = []byte("// Code generated by kk; BUT FEEL FREE TO EDIT.")

type Config struct {
	ModuleName  string `long:"modulename" description:"golang module name" required:"false"`
	ProjectType string `long:"projecttype" description:"golang project typo e.g. rest, grpc, graphql" required:"false" default:"rest"`
}

func main() {
	config := &Config{}
	parser := flags.NewParser(config, flags.Default)
	parser.ShortDescription = "kk - a Golang tool"
	parser.LongDescription = "kk - easily create, setup and extend a Golang projects. No more copying files and endless renaming."
	if _, err := parser.Parse(); err != nil {
		log.Fatalf("Parsing arguments failed: %s", err)
	}

	restTemplateDir := "templates/rest"

	if err := fs.WalkDir(content, restTemplateDir, func(path string, d fs.DirEntry, err error) error {
		if path == restTemplateDir {
			return nil
		}

		if d.IsDir() {
			if err := os.MkdirAll(cleanPath(path, restTemplateDir), os.ModePerm); err != nil {
				log.Fatalf("Making %s dir: %s", path, err)
			}
		} else if strings.HasSuffix(path, ".gotmpl") {
			tt := template.Must(template.ParseFS(content, path))
			for _, t := range tt.Templates() {
				filePath := strings.Replace(cleanPath(path, restTemplateDir), ".gotmpl", ".go", 1)
				if currentFileBytes, err := os.ReadFile(filePath); err != nil {
					log.Fatalf("Reading file %s: %s", filePath, err)
				} else if bytes.HasPrefix(currentFileBytes, feelFreeToEditPrefix) {
					continue
				} else {
					f, err := os.Create(filePath)
					if err != nil {
						log.Fatalf("Creating file %s: %s", filePath, err)
					}
					if err := t.Execute(f, config); err != nil {
						log.Fatalf("Executing %s: %s", path, err)
					}
				}
			}
		} else {
			return nil
		}
		return nil
	}); err != nil {
		log.Fatalf("Walking through the %s failed: %s", restTemplateDir, err)
	}
}

func cleanPath(path, prefix string) string {
	return strings.TrimPrefix(strings.TrimPrefix(path, prefix), "/")
}
